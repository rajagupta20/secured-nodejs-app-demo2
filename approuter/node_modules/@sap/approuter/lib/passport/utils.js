'use strict';

const jwtDecode = require('jwt-decode');
const VError = require('verror').VError;
const headerUtil = require('../utils/header-util');
const urlUtils = require('../utils/url-utils');
const iasUtils = require('../utils/ias-utils');
const uaaUtils = require('../utils/uaa-utils');
const pathUtil = require('../utils/path-util');
const request = require('../utils/request-utils');
const loggerUtils = require('../utils/logger');
const tracer = loggerUtils.getTracer(__filename);
const urijs = require('urijs');
const configUtils = require('../utils/configuration-utils');

module.exports = {
  MAX_ATTEMPTS_NUMBER: 3,
  storeToken: function (req, options, done) {
    req.session.regenerate(function (err) {
      if (err) {
        return done(err);
      }

      req.session.user = module.exports.getUserProperties(options);
      req.session.save();
      done(null, req.session.user);
    });
  },

  getUserProperties: function (options) {
    const token = jwtDecode(options.accessToken);
    const userName = token.user_name || token.email;
    const userId = token.user_uuid || userName;
    let scopes = [];
    const optionsScope = options.xsuaaToken && options.xsuaaToken.scope ? options.xsuaaToken.scope : options.scope;
    if (optionsScope) {
      scopes = optionsScope.trim ? optionsScope.trim().split(' ') : optionsScope;
    }
    return {
      id: userId,
      name: userName || 'n/a', // 'n/a' is for passport
      token: {
        accessToken: options.accessToken,
        idToken: options.idToken,
        authenticationType: options.oauthOptions ? options.oauthOptions.authenticationType : 'xsuaa', // if there is no oauthOptions, it is service2approuter flow that supports only xsuaa now
        expiryDate: module.exports.getExpiresAt(options.expiresIn).getTime(),
        refreshToken: options.refreshToken,
        oauthOptions: options.oauthOptions
      },
      tenantid: token.zid || token.zone_uuid,
      scopes: scopes,
      tenant: token.ext_attr && token.ext_attr.zdn,
      urlTenant: options.urlTenant,
      xsuaaToken: options.xsuaaToken
    };
  },

  getExpiresAt: function (duration) {
    // respect network latency if possible
    let expiresIn;
    if (duration > 180) {
      expiresIn = duration - 120;
    } else {
      expiresIn = duration;
    }
    return new Date(new Date().getTime() + expiresIn * 1000);
  },

  getCallBackUrl: function (req) {
    const appRouterUrl = urlUtils.buildAppRouterUrl(req);
    const loginCallback = multipleAuthTypes(req) ? req.routerConfig.appConfig.login.callbackEndpoint + '?authType=' + pathUtil.pathAuthenticationType(req) :
      req.routerConfig.appConfig.login.callbackEndpoint;
    let proxyPrefix = '';

    if (req.headers['x-forwarded-path']) {
      let toCutOut = req.url.length;
      const parsedUrl = urijs.parse(req.url);
      if (req.headers['x-forwarded-path'].indexOf(loginCallback) > -1 && parsedUrl.query) {
        toCutOut = loginCallback.length;
      }
      const parsedXForwardedPath = urijs.parse(req.headers['x-forwarded-path']);
      proxyPrefix = parsedXForwardedPath.path.substr(0, parsedXForwardedPath.path.length - toCutOut +
        (req.url[0] === '/' ? 1 : 0));
    }
    return urlUtils.join(appRouterUrl + proxyPrefix, loginCallback);
  },

  loadOauthOptions: function (req, cb) {
    const authenticationType = pathUtil.pathAuthenticationType(req);
    module.exports.getAuthConfig(req, authenticationType, function (err, authOptions) {
      if (err) {
        return cb(err);
      }
      const url = authOptions.url;
      const zoneId = req.zoneInfo && req.zoneInfo.zoneId;
      const options = {
        authorizationURL: urlUtils.join(url, authenticationType === 'ias' ? '/oauth2/authorize' : '/oauth/authorize'),
        tokenURL: urlUtils.join(authOptions.certurl || url, authenticationType === 'ias' ? '/oauth2/token' : '/oauth/token'),
        clientid: authOptions.clientid,
        clientsecret: authOptions.clientsecret,
        certificate: authOptions.certificate,
        key: authOptions.key,
        url: url,
        callbackURL: module.exports.getCallBackUrl(req),
        customHeaders: {'x-correlationid': headerUtil.getCorrelationId(req)},
        scope: authenticationType === 'ias' ? 'openid' : null,
        authenticationType: authenticationType,
        iasZoneId: authenticationType === 'ias' ? zoneId : undefined
      };

      headerUtil.updateSapPassport(req.headers, options.customHeaders);
      cb(null, options);
    });
  },

  getAccessTokenCallback: function (strategy, req) {
    return function accessTokenCallback(err, result) {
      if (err) {
        const error = new VError(err, 'Could not obtain access token');
        error.status = err.status;
        return strategy.error(error);
      }

      function verified(err, user, info) {
        if (err) {
          return strategy.error(err);
        }
        if (!user) {
          return strategy.fail(info);
        }
        strategy.success(user, info);
      }

      try {
        strategy.verify(req, result, verified);
      } catch (ex) {
        return strategy.error(ex);
      }
    };
  },

  callUaa: function (requestOptions, shouldDoRequest, cb) {
    const requestStart = Date.now();
    let attemptsNum = module.exports.MAX_ATTEMPTS_NUMBER;

    function doRequest() {
      if (shouldDoRequest) {
        var error = shouldDoRequest();
        if (error) {
          return cb(error);
        }

      }
      request.post(requestOptions, function onResponse(err, res, body) {
        if (err || res.statusCode !== 200) {
          tracer.info(err, 'Request attempt %d to authentication service at %s failed in %d ms.', module.exports.MAX_ATTEMPTS_NUMBER - attemptsNum + 1, requestOptions.url, Date.now() - requestStart);
          --attemptsNum;
          if (!attemptsNum) {
            if (res && res.statusCode !== 200) {
              const error = new VError('unexpected response from authentication service at %s: status code: %d, response body: "%s"',
                requestOptions.url, res.statusCode, body);
              error.status = res.statusCode;
              return cb(error);
            }
            return cb(new VError(err, 'Request to authentication service failed'));
          }
          return doRequest();
        }
        try {
          var responseJSON = JSON.parse(body);
        } catch (err) {
          return cb(new VError(err, 'unexpected response from authentication service. Expected json, got: "%s"', body));
        }
        cb(null, responseJSON);
      });
    }

    doRequest();
  },

  getAuthConfig: function (req, authenticationType, cb) {
    if (authenticationType === 'ias') {
      return iasUtils.getIasConfig(req, cb);
    } else {
      return uaaUtils.getUaaConfig(req, cb);
    }
  },

  getHttpCertificates: function (certificate) {
    let chain = certificate.split('-----BEGIN CERTIFICATE-----');
    let certsArray = [];
    for (let i = 0; i < chain.length; i++) {
      let cert = chain[i];
      if (!(cert.length !== 0)) {
        continue;
      }
      if (cert.match(/-END CERTIFICATE-/)) {
        certsArray.push('-----BEGIN CERTIFICATE-----' + cert);
      }
    }
    return {
      cert: certsArray[0] + certsArray[1]
    };
  },

  getUrlTenant: function (req) {
    let tenant = null;
    if (process.env.TENANT_HOST_PATTERN) {
      let requestHost = urlUtils.getAppRouterHost(req);
      let tenantHostPattern = configUtils.constructRegExp(process.env.TENANT_HOST_PATTERN);
      tenant = uaaUtils.retrieveTenantFromURL(requestHost, tenantHostPattern);
    }
    return tenant;
  },

  getTenantInfo: function (req) {
    if (!process.env.TENANT_HOST_PATTERN) {
      let user = req.session && req.session.user;
      return { 'multitenant': false, 'tenant': user && user.tenant };
    } else {
      return { 'multitenant': true, 'tenant': this.getUrlTenant(req) };
    }
  }

};

function multipleAuthTypes(req) {
  return req && req.routerConfig && req.routerConfig.iasConfig && req.routerConfig.iasConfig.options &&
    req.routerConfig.iasConfig.options.url && req.routerConfig.uaaConfig && req.routerConfig.uaaConfig.options &&
    req.routerConfig.uaaConfig.options.url;
}